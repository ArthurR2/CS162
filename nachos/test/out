++OPENFILE: [STARTED]
++OPENFILE: open the first file test1.in
++OPENFILE: open the second file test2.in
++OPENFILE: open the third file test3.in
++OPENFILE: [END]
              0th variations
++FILESYSCALL VAR0: [STARTED]
++FILESYSCALL VAR0: creates a file, checks syscall creat works
++FILESYSCALL VAR0: SUCCESS
++FILESYSCALL Run the                                1th variations
++FILESYSCALL VAR1: [STARTED]
++FILESYSCALL VAR1: calls syscall creat/close/unlink and checks that they work
++FILESYSCALL VAR1: calls syscall creat to create file testVar2.txt
++FILESYSCALL VAR1: calls syscall close
++FILESYSCALL VAR1: calls syscall unlink to delete testVar2.txt
++FILESYSCALL VAR1: calls syscall creat again to create file testVar2.txt
++FILESYSCALL VAR1: calls syscall unlink to delete testVar2.txt without close
++FILESYSCALL VAR1: calls syscall unlink again to see if testVar2.txt is existed.
++FILESYSCALL VAR1: SUCCESS
++FILESYSCALL Run the                                2th variations
++FILESYSCALL VAR2: tests if your syscall close actually closes the file++FILESYSCALL VAR2: [STARTED]
++FILESYSCALL VAR2: creates a file, checks syscall creat works
++FILESYSCALL VAR2: close the file created just now
++FILESYSCALL VAR2: open the file created just now
++FILESYSCALL VAR2: close the file just opened
++FILESYSCALL VAR2: calls syscall unlink to delete testVar1.txt
++FILESYSCALL VAR2: close the file created just now
++FILESYSCALL VAR2: open the file created just now
++FILESYSCALL VAR2: close the file just opened
++FILESYSCALL VAR2: calls syscall unlink to delete testVar1.txt
++FILESYSCALL VAR2: close the file created just now
++FILESYSCALL VAR2: open the file created just now
++FILESYSCALL VAR2: close the file just opened
++FILESYSCALL VAR2: calls syscall unlink to delete testVar1.txt
++FILESYSCALL VAR2: close the file created just now
++FILESYSCALL VAR2: open the file created just now
++FILESYSCALL VAR2: close the file just opened
++FILESYSCALL VAR2: calls syscall unlink to delete testVar1.txt
++FILESYSCALL VAR2: close the file created just now
++FILESYSCALL VAR2: open the file created just now
++FILESYSCALL VAR2: close the file just opened
++FILESYSCALL VAR2: calls syscall unlink to delete testVar1.txt
++FILESYSCALL VAR2: close the file created just now
++FILESYSCALL VAR2: open the file created just now
++FILESYSCALL VAR2: close the file just opened
++FILESYSCALL VAR2: calls syscall unlink to delete testVar1.txt
++FILESYSCALL VAR2: close the file created just now
++FILESYSCALL VAR2: open the file created just now
++FILESYSCALL VAR2: close the file just opened
++FILESYSCALL VAR2: calls syscall unlink to delete testVar1.txt
++FILESYSCALL VAR2: close the file created just now
++FILESYSCALL VAR2: open the file created just now
++FILESYSCALL VAR2: close the file just opened
++FILESYSCALL VAR2: calls syscall unlink to delete testVar1.txt
++FILESYSCALL VAR2: close the file created just now
++FILESYSCALL VAR2: open the file created just now
++FILESYSCALL VAR2: close the file just opened
++FILESYSCALL VAR2: calls syscall unlink to delete testVar1.txt
++FILESYSCALL VAR2: close the file created just now
++FILESYSCALL VAR2: open the file created just now
++FILESYSCALL VAR2: close the file just opened
++FILESYSCALL VAR2: calls syscall unlink to delete testVar1.txt
++FILESYSCALL VAR2: SUCCESS
++FILESYSCALL Run the                                3th variations
++FILESYSCALL VAR3: [STARTED]
++FILESYSCALL VAR3: tests if your syscall open fails gracefully when stubFileSystem's openfile limit's exceeded
++FILESYSCALL VAR3: will open                               13 files
++FILESYSCALL VAR3: opening the                                0th file
++FILESYSCALL VAR3: opening the                                1th file
++FILESYSCALL VAR3: opening the                                2th file
++FILESYSCALL VAR3: opening the                                3th file
++FILESYSCALL VAR3: opening the                                4th file
++FILESYSCALL VAR3: opening the                                5th file
++FILESYSCALL VAR3: opening the                                6th file
++FILESYSCALL VAR3: opening the                                7th file
++FILESYSCALL VAR3: opening the                                8th file
++FILESYSCALL VAR3: opening the                                9th file
++FILESYSCALL VAR3: opening the                               10th file
++FILESYSCALL VAR3: opening the                               11th file
++FILESYSCALL VAR3: opening the                               12th file
++FILESYSCALL VAR3: opening the                               13th file
++FILESYSCALL VAR3: SUCCESS
++FILESYSCALL Run the                                4th variations
++FILESYSCALL VAR4: [STARTED]
++FILESYSCALL VAR4: tests if all files get closed when process exits normally
++FILESYSCALL VAR4: invoke syscall exec openfile.coff
++FILESYSCALL VAR4: Child process id is                                2
++FILESYSCALL VAR4: SUCCESS
++FILESYSCALL Run the                                5th variations
++FILESYSCALL VAR5: [STARTED]
++FILESYSCALL VAR5: open mv.c
++FILESYSCALL VAR5: file handle                                2 
++FILESYSCALL VAR5: invoke read/write in a loop
#include "syscall.h"
#include "stdio.h"
#include "stdlib.h"

#define BUFSIZE 1024

char buf[BUFSIZE];

int main(int argc, char** argv)
{
  int src, dst, amount;

  if (argc!=3) {
    printf("Usage: cp <src> <dst>\n");
    return 1;
  }

  src = open(argv[1]);
  if (src==-1) {
    printf("Open to open %s\n", argv[1]);
    return 1;
  }

  creat(argv[2]);
  dst = open(argv[2]);
  if (dst==-1) {
    printf("Unable to create %s\n", argv[2]);
    return 1;
  }

  while ((amount = read(src, buf, BUFSIZE))>0) {
    write(dst, buf, amount);
  }

  close(src);
  close(dst);
  unlink(argv[1]);

  return 0;
}
++FILESYSCALL VAR5: Please check above content manually that read from mv.c
++FILESYSCALL VAR5: END
++FILESYSCALL Run the                                6th variations
++FILESYSCALL VAR6: [STARTED]
++FILESYSCALL VAR6: open mv.c
++FILESYSCALL VAR6: file handle                                2 
++FILESYSCALL VAR6: file handle                                3 
++FILESYSCALL VAR6: invoke read/write in a loop
++FILESYSCALL VAR6: Child process id is                                3
++FILESYSCALL VAR6: SUCCESS
++FILESYSCALL Run the                                7th variations
++FILESYSCALL VAR7: [STARTED]
++FILESYSCALL Run the                                8th variations
++FILESYSCALL VAR8: [STARTED]
++FILESYSCALL VAR8: open mv.c
++FILESYSCALL VAR8: file handle                                2 
++FILESYSCALL VAR8: file handle                                3 
++FILESYSCALL VAR8: invoke read/write some times
++FILESYSCALL VAR8*: invoke write as buf address is NULL
